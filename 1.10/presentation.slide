As Novidades do Go 1.10
17 Mar 2018
Tags: golang, 1.10

Ricardo Longa
Software Craftsman, Neoway
ricardo.longa@neoway.com.br
@ricardolonga 

Ellen KÃ¶rbes
Desempregada \o/
e@ellenkorbes.com
@ellenkorbes

* Go 1.10

- Ã‰ o 11Âº release da linguagem.

- LanÃ§ado em 16 de fevereiro de 2018.

- O Go Playground jÃ¡ roda 1.10, teste com:

     fmt.Println(runtime.Version())

* TÃ³picos

Vamos falar sobre:

- O spec da linguagem
- Os ports
- As ferramentas
- A standard library
- Performance

* Linguagem

* Escove bem os seus bits!

Foi corrigida uma inconsistÃªncia na linguagem:

    const s = 10
    a := make([]byte, 1.0<<s) // Na 1.9: vÃ¡lido.
    _ = a[1.0<<s]             // Na 1.9: erro.

Agora podemos utilizar consistentemente constantes nÃ£o-tipadas como operador em operaÃ§Ãµes de shifting sobre valores nÃ£o constantes (1.0 no exemplo acima). O tipo da constante serÃ¡ `int` nesses casos. (Para mais, [[https://go-review.googlesource.com/c/go/+/60230][clique]].)

Ufa!

* NÃ£o, sÃ©rio.

.image shift.png 575 _

* MÃ©todos

Chamadas de mÃ©todos do tipo `struct{io.Reader}.Read()`, que jÃ¡ eram aceitas pelo compilador, agora sÃ£o oficialmente aceitas pela gramÃ¡tica da linguagem. Exemplo:

    type MyType struct { io.Reader }

    func main() {
        m := MyType{}
        dst := make([]byte, 10)
        l, err := struct{io.Reader}.Read(m, dst)
        _, _, _ = l, err, dst
    }

Mas... erros:

    go.struct { io.Reader }.Read: call to external function
    main.main: relocation target go.struct { io.Reader }.Read not defined
    main.main: undefined: "go.struct { io.Reader }.Read"

Vamos ter que esperar pela 1.11 para poder utilizar.

* Ports

* TÃ©dio:

- FreeBSD: agora requer FreeBSD 10.3 or later
- NetBSD: requer NetBSD 8, que ainda nÃ£o foi lanÃ§ado. GOARCH amd64 e 386 funcionam, arm tÃ¡ quebrado.
- OpenBSD: a prÃ³xima versÃ£o (1.11) vai requerer OpenBSD 6.2.
- Para sistemas MIPS de 32-bits, agora temos uma variÃ¡vel GOMIPS, que pode ser `hardfloat` ou `softfloat`, e serve para determinar se vamos utilizar instruÃ§Ãµes de hardware ou emulaÃ§Ã£o atravÃ©s de software para computaÃ§Ãµes com floating points. Bom saber, caso vocÃª queira rodar cÃ³digo nos processadores MIPS do seu Nintendo 64 ou Playstation 2.

* Importante:

Go 1.10 Ã© a Ãºltima versÃ£o que vai rodar em:

- OS X 10.8 Mountain Lion ou OS X 10.9 Mavericks. Go 1.11 vai rodar somente em OS X 10.10 Yosemite ou mais recentes.
- Windows XP ou Windows Vista. Go 1.11 vai rodar somente em Windows 7 ou mais recentes.

Detalhe:

"And even after Go 1.12 comes out, you can keep using Go 1.10, we just won't fix bugs in it. But if you're happy with it (or Go 1.9 or whatever version), great. You won't get security fixes, but if you are running XP you're not worried about that." â€” [[https://github.com/golang/go/issues/23380#issuecomment-356346724][Russ Cox]]

* Ferramentas

* Set-up:

`GOPATH` virou opcional na 1.8.

`GOROOT` tambem Ã© opcional agora.

`GOTMPDIR` Ã© nova, e determina onde vÃ£o os arquivos temporÃ¡rios.

* Caching

*go*build* agora mantem os builds recentes de packages em cache, em separado das packages instaladas em *$GOROOT/pkg* ou *$GOPATH/pkg*.

Ou seja, antes tinhamos *go*build*-i* e *go*test*-i*:

"The -i flag installs the packages that are dependencies of the target."

Que agora se tornam desnecessÃ¡rios.

Alem disso, *go*build* agora detecta que os packages estÃ£o out-of-date com base nos arquivos fonte, build flags, e metadata dos packages compilados. A Ãºltima data de modificaÃ§Ã£o nÃ£o Ã© mais consultada, ou relevante.

* Caching

Este cache se aplica nÃ£o somente a *go*build* mas tambem a *go*test*.

Para que isso ocorra algumas condiÃ§Ãµes devem ser observadas, dentre elas:

- os testes devem passar
- o executÃ¡vel e a linha de comando devem bater com uma execuÃ§Ã£o anterior
- os arquivos e environment variables devem permanecer os mesmos

Para ignorar o cache, rode com o flag *-count=1*.

E o output dos testes ficarÃ¡ levemente diferente para os testes em cache. Ao invÃ©s de mostrar o tempo de execuÃ§Ã£o, o output serÃ¡ *(cached)*.

* Caching

Exemplo: uma cÃ³pia do Terraform num sistema sem nenhum package instalado ou cache prÃ©-pronto:

- O primeiro *go*test*./...* terminou em aprox. 3 minutos.

    [...]
    FAIL    github.com/hashicorp/terraform/config/module    6.173s
    ok      github.com/hashicorp/terraform/dag      2.712s
    [...]

- O segundo *go*test*./...* terminou  em menos de 40 segundos.

    [...]
    FAIL    github.com/hashicorp/terraform/config/module    7.060s
    ok      github.com/hashicorp/terraform/dag      (cached)
    [...]

*** MÃ¡quina Windows 10 + i7 6700HQ (8 cores) + 32GB RAM

* Testes

AlÃ©m de caching, hÃ¡ algumas diferenÃ§as no *go*test*:

- Algumas verificaÃ§Ãµes do *go*vet* rodam antes dos testes. Ou seja: escreve esse cÃ³digo direito.
- A flag *-coverpkg* agora pode calcular a cobertura de mÃºltiplas packages:
    go test -coverpkg=all -coverprofile cover.out ./...
- A flag *-failfast* possibilita que os testes parem assim que seja encontrada a primeira falha (exceto testes paralelos, que continuam rodando atÃ© terminar).

* go build

As seguintes flags do *go*build* agora se aplicam exclusivamente aos packages listados na linha de comando: *-asmflags*, *-gcflags*, *-gccgoflags*, e *-ldflags*.

Exemplo:

 go build -gcflags=-m mypkg

Aqui a flag *-m* se aplica ao package *mypkg*, mas nÃ£o Ã s suas dependÃªncias.

* Um parÃªnteses: slicing com 3 Ã­ndices

Dois Ã­ndices:

.play bytes/slicing.go /START/,/END/

Aqui as slices `hello` e `text` compartilham do mesmo array subjacente, portanto uma mudanÃ§a em uma pode afetar a outra.

* Um parÃªnteses: slicing com 3 Ã­ndices

TrÃªs Ã­ndices:

.play bytes/slicing2.go /START/,/END/

Aqui temos um cap diferente para o slice resultado, o que faz com que as slices nÃ£o possam compartilhar o mesmo array subjacente.

* gofmt

ExpressÃµes complexas para slicing com 3 Ã­ndices agora tem espaÃ§amento consistente. 

Antes era:

    a[i+j : k:l]

Agora Ã©:

    a[i+j : k : l]

* gofmt

Interfaces com um Ãºnico mÃ©todo escritos em uma linha sÃ³, que costumam ser usadas para tipagem, nÃ£o sÃ£o mais quebradas em diversas linhas:

Antes era:

    if c, ok := v.(interface {
        Close() error
    }); ok {
    }

Agora pode ser:

    if c, ok := v.(interface{ Close() error }); ok {
    }

* gofmt

Se uma literal composta tiver como conteÃºdo somente comentÃ¡rios, agora este comentÃ¡rio serÃ¡ indentado.

Antes:

    var _ = []T{/* comentÃ¡rio */}
    â†“
    var _ = []T{
    /* comentÃ¡rio */
    }

Agora:

    var _ = []T{ /* comentÃ¡rio */ }
    â†“
    var _ = []T{
        /* comentÃ¡rio */
    }

* Outros

- `go`fix` auxilia em migrar imports de `golang.org/x/net/context` para `context` no seu cÃ³digo, mantendo-o compatÃ­vel com versÃµes acima de 1.9.

    go tool fix -r context your/package

- `go`get` agora suporta o SCM [[https://fossil-scm.org][Fossil]].

- HÃ¡ documentaÃ§Ã£o nova disponÃ­vel sobre diagnÃ³sticos: [[https://golang.org/doc/diagnostics.html]]

* Standard library

- NÃ£o hÃ¡ packages novos

* bytes

Os mÃ©todos `Fields`, `FieldsFunc`, `Split` e `SplitAfter` usam o mesmo esquema do slicing com 3 Ã­ndices para evitar que a slice resultante possa sobrescrever a original. (A mudanÃ§a no cap faz com que as slices nÃ£o possam compartilhar o mesmo array subjacente.)

Exemplo:

.play bytes/fields.go /START/,/END/

* bytes

Output 1.9:

    text:  len: 18 | cap: 32 | "Boa noite, galera!"
    hello: len:  3 | cap: 32 | "Boa"
    hello: len:  4 | cap: 32 | "Boa#"
    text:  len: 18 | cap: 32 | "Boa#noite, galera!"

Output 1.10:

    text:  len: 18 | cap: 32 | "Boa noite, galera!"
    hello: len:  3 | cap:  3 | "Boa"
    hello: len:  4 | cap:  8 | "Boa#"
    text:  len: 18 | cap: 32 | "Boa noite, galera!"

* flags

FormataÃ§Ã£o quando tem \n na descriÃ§Ã£o de um flag:

.play flag/main.go /START/,/END/

Antes:

    -x int
        Essa explicaÃ§Ã£o Ã©
    bem longa, sacoÃ©?
    -y int
        Essa Ã© curtinha.

Agora:

    -x int
        Essa explicaÃ§Ã£o Ã©
        bem longa, sacoÃ©?
     -y int
        Essa Ã© curtinha.

* go/doc

Exemplo:

.code coisas/coisas.go

* go/doc

    $ go doc coisas

Antes:

    package coisas // import "github.com/ellenkorbes/floripa-gophers/1.10/coisas"

    func ManyCoisas() []Coisa
    type Coisa
        func NewCoisa() *Coisa

Agora:

    package coisas // import "github.com/ellenkorbes/floripa-gophers/1.10/coisas"

    type Coisa
        func ManyCoisas() []Coisa
        func NewCoisa() *Coisa

* text/template

Agora temos `{{break}}` e `{{continue}}` no `{{range}}`:

.play template/main.go /var tmpl/,/\)\)/

Curiosamente, isto nÃ£o estÃ¡ implementado na package html/template.

* strings

Isso Ã© bastante comum:

    var buf bytes.Buffer
    fmt.Fprintln(&buf, "E aÃ­, galera!")
    fmt.Printf(buf.String())

Mas `.String()` requer alocaÃ§Ãµes de memÃ³ria jÃ¡ que ele converte `[]byte` para `string`.

Agora temos:

	var b strings.Builder
	fmt.Fprintln(&b, "E aÃ­, galera!")
	fmt.Printf(b.String())

* strings

    for i := 0; i < 10000; i++ {
        fmt.Fprintf(w, "ðŸ˜Š")
        out = w.String()
    }

Nesta funÃ§Ã£o temos:

    $ go test -bench=. -benchmem
    goos: darwin
    goarch: amd64
    pkg: github.com/campoy/talks/go1.10/strings
    BenchmarkBuffer-4            100          20861915 ns/op        215641272 B/op     10317 allocs/op
    BenchmarkBuilder-4          3000            535081 ns/op          153647 B/op         22 allocs/op
    PASS
    ok      github.com/campoy/talks/go1.10/strings  3.626s

Mas se comentarmos a linha 

    out = w.String()
    
aÃ­ a performance Ã© levemente pior.

* unicode

novos emoji

* bufio

- Reader e Writer agora tem os mÃ©todos *Reader.Size* e *Writer.Size* que mostram o tamanho atual do buffer.

* encoding/json

- O *Decoder* agora possui o mÃ©todo *DisallowUnknownFields* que faz com que a presenÃ§a de campos desconhecidos no JSON seja tratada como erro. O default Ã© simplesmente descartar os campos desconhecidos.

- *Unmarshal* can no longer decode into fields inside embedded pointers to unexported struct types, because it cannot initialize the unexported embedded pointer to point at fresh storage. *Unmarshal* now returns an error in this case. This means you may need to update your code or a "breaking change" will happen, which could be hidden if the code is not properly handling errors

* math

the new functions *Round* and *RoundToEven* round their arguments to the nearest floating-point integer; *Round* rounds a half-integer to its larger integer neighbor (away from zero) while *RoundToEven* rounds a half-integer to its even integer neighbor

* math/rand 

- math/rand - agora temos a funÃ§Ã£o *Shuffle* e o mÃ©todo correspondente *Rand.Shuffle* que ordenam aleatoriamente (embaralham) uma sequÃªncia.

    func ExampleShuffle() {
        rand.Seed(time.Now().UnixNano())
        numbers := []byte("12345")

        rand.Shuffle(len(numbers), func(i, j int) {
            numbers[i], numbers[j] = numbers[j], numbers[i]
        })

        for i := range numbers {
            fmt.Printf("%c ", numbers[i])
        }

        // Output:
        // 3 4 1 5 2
    }

*Aviso*: Sem um *rand.Seed()* a ordem do embaralhamento serÃ¡ previsÃ­vel.

* net

*TCPListener* and *UnixListener* now implement -syscall.Conn-, to allow setting options on the underlying file descriptor using *syscall.RawConn.Control*

the *Conn* implementations returned by *Pipe* now support setting read and write deadlines

the *IPConn.ReadMsgIP*, *IPConn.WriteMsgIP*, *UDPConn.ReadMsgUDP*, and *UDPConn.WriteMsgUDP*, methods are now implemented on *Windows*

-

the *Conn* and *Listener* implementations in this package now guarantee that when *Close* returns, the underlying file descriptor has been closed.

In earlier releases, if the *Close* stopped pending I/O in other goroutines, the closing of the file descriptor could happen in one of those goroutines shortly after *Close* returned

This is an important change as it now guarantees that you can do

    net.Listen(...)
    Close()
    net.Listen()

and safely be able to acquire new connections. Before, in 1.9 or older, depending on timing and your OS, this could throw an error due to the port being still in use.

* net/http

- net/http - on the client side, an *HTTP*proxy*, most commonly configured by *ProxyFromEnvironment*, can now be specified as an *https://*URL*, meaning that the client connects to the proxy over HTTPS before issuing a standard, proxied HTTP request. Previously, HTTP proxy URLs were required to begin with *http://* or *socks5://*
- net/http - on the server side, *FileServer* and its single-file equivalent *ServeFile* now apply *If-Range* checks to HEAD requests. *FileServer* also now reports directory read failures to the *Server's*ErrorLog*
- net/http - the content-serving handlers also now *omit* the *Content-Type* header when serving zero-length content
- net/http - *ResponseWriter's* *WriteHeader* method now panics if passed an invalid (non-3-digit) status code
- net/http - *Redirect* now sets the *Content-Type* header before writing its HTTP response

* net/url

- net/url - *ResolveReference* now preserves multiple leading slashes in the target URL. Previously it rewrote multiple leading slashes to a single slash, which resulted in the *http.Client* following certain redirects incorrectly

* os

- os - *File* adds new methods *SetDeadline*, *SetReadDeadline*, and *SetWriteDeadline* that allow setting I/O deadlines when the underlying file descriptor supports non-blocking I/O operations. The definition of these methods matches those in *net.Conn*
- os - also matching *net.Conn*, *File's* *Close* method now guarantee that when *Close* returns, the underlying file descriptor has been closed
- unicode - the unicode package and associated support throughout the system has been upgraded from version 9.0 to *Unicode*10.0*, which adds 8,518 new characters, including four new scripts, one new property, a Bitcoin currency symbol, and 56 new emoji

* Performance

* Garbage collector:

Mesma coisa.

* Performance de execuÃ§Ã£o:

Mesma coisa.

* Performance de compilaÃ§Ã£o:

10% mais rÃ¡pida!

    $ benchstat go1.9.3.txt go.1.10rc1.txt 
    name       old time/op       new time/op       delta
    Template         234ms Â± 4%        231ms Â± 4%     ~     (p=0.101 n=10+8)
    Unicode          107ms Â± 1%        109ms Â± 6%     ~     (p=0.211 n=9+10)
    GoTypes          742ms Â± 2%        744ms Â± 2%     ~     (p=0.905 n=9+10)
    Compiler         3.50s Â± 3%        3.54s Â± 5%     ~     (p=0.393 n=10+10)
    SSA              6.95s Â± 4%        9.04s Â± 5%  +29.98%  (p=0.000 n=10+10)
    Flate            149ms Â± 2%        147ms Â± 5%   -1.53%  (p=0.035 n=10+9)
    GoParser         189ms Â± 3%        183ms Â± 3%   -3.44%  (p=0.002 n=9+9)
    Reflect          476ms Â± 5%        489ms Â± 6%   +2.90%  (p=0.043 n=10+10)
    Tar              134ms Â± 1%        220ms Â± 3%  +64.14%  (p=0.000 n=9+10)
    XML              258ms Â± 6%        266ms Â± 6%   +2.90%  (p=0.043 n=10+10)
    StdCmd           19.1s Â± 1%        17.1s Â± 3%  -10.57%  (p=0.000 n=10+10)

.caption Following [[https://golang.org/x/tools/cmd/compilebench][https://golang.org/x/tools/cmd/compilebench]].
.caption Run on a Google Compute Engine instance with 8 cores.

* Extras

* UnlockOSThread/LockOSThread

If before, in nested calls, *UnlockOSThread* would need to be called only once to unlock the thread, now it will need to be called as many times as *LockOSThread* was called.

You may have noticed the *<autogenerated>* frame (line) in the stack traces before.
This is now hidden, unless a panic or other issue happens in it.
This also means that if your code would call *runtime.Caller* with a certain number of skip frames, then this change will be a "breaking change" in its behaviour as the *<autogenerated>* frames will not be counted there either.

* Runtime

Go 1.10 also introduces *soft* and *hard*goals* (limits) for *garbage*collection*.

The soft limit is the current value of the GOGC while the hard limit is 10% higher than the soft limit.

Heavy GC reliant applications (so far only benchmarks) shows that thereâ€™s an increase in the heap size of the application.

These limits are not currently configurable, see [[https://golang.org/cl/59970]] for the discussion on it.

* CGO support

C typedefs such as *typedef*X*Y* now are treated as Go aliases. You'll be able to use *C.X* and *C.Y* interchangeably in Go now, as if they would be Go aliases, *type*X*=*Y*.

You can now pass Go strings directly to C. This is done by declaring a C function in a Go file with a parameter type of the special type name *_GoString_*. To access the string length, youâ€™ll need to call *size_t* *_GoStringLen(_GoString_*s)* an in order to get the pointer to the string contents, youâ€™ll need use *const*char* ***_GoStringPtr(_GoString_*s)*.

Some C types that were previously mapped to a pointer type in Go are now mapped to *uintptr* type.
A couple of these types are *CFTypeRef* in Darwin's CoreFoundation framework and the *jobject* in Javaâ€™s JNI interface.
Youâ€™ll need to initialize the values for the affected types with *0* instead of *nil*.
This is a breaking change but thankfully you can fix this quickly and automatically by running

 go tool fix -r cftype your/package or go tool fix -r jni your/package

* Agradecimentos:

- Francesc Campoy
- Florin PÄƒÈ›an
- Dinesh Kumar